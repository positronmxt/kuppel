#!/usr/bin/env python3
"""Check how well *inner* frame corners meet at shared nodes.

This is a pure-Python diagnostic (no FreeCAD required).

It computes each panel's inner-loop corners by the same inset logic used by
`freecad_dome.panels.PanelBuilder`, lifts those 2D inner corners back to 3D,
then groups points by the original dome node index.

If panel frames are generated by per-panel planar inset, inner corner points at
one node generally will *not* coincide across all incident panels. This script
quantifies that spread.

Usage:
  python3 scripts/check_node_inner_corner_spread.py

Env:
- DOME_CONFIG (default: configs/base.json)
- DOME_PANEL_FRAME_INSET_M (optional override)
- DOME_PANEL_FRAME_PROFILE_M (optional override, "WIDTH,HEIGHT")
- DOME_TOL_M (default: 0.0005) tolerance for reporting (m)

Output:
- Writes `exports/node_inner_corner_spread.json`
- Exit code 1 if any node exceeds tolerance
"""

from __future__ import annotations

import json
import os
import sys
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))


def _parse_profile(value: str | None) -> tuple[float, float] | None:
    if not value:
        return None
    raw = value.replace(" ", "")
    if "," in raw:
        parts = raw.split(",", 1)
    elif "x" in raw.lower():
        parts = raw.lower().split("x", 1)
    else:
        parts = raw.split(";", 1)
    if len(parts) != 2:
        raise ValueError("DOME_PANEL_FRAME_PROFILE_M must be 'WIDTH,HEIGHT'")
    return (float(parts[0]), float(parts[1]))


def _dist(a: tuple[float, float, float], b: tuple[float, float, float]) -> float:
    dx = b[0] - a[0]
    dy = b[1] - a[1]
    dz = b[2] - a[2]
    return (dx * dx + dy * dy + dz * dz) ** 0.5


def main() -> int:
    from freecad_dome import icosahedron, parameters, tessellation
    from freecad_dome.panels import PanelBuilder

    config = os.environ.get("DOME_CONFIG", "configs/base.json")
    inset_raw = os.environ.get("DOME_PANEL_FRAME_INSET_M")
    profile_raw = os.environ.get("DOME_PANEL_FRAME_PROFILE_M")
    tol_m = float(os.environ.get("DOME_TOL_M", "0.0005"))

    overrides: dict[str, object] = {
        "generate_panel_frames": True,
        "generate_panel_faces": False,
        "generate_struts": False,
    }
    if inset_raw:
        overrides["panel_frame_inset_m"] = float(inset_raw)
    profile = _parse_profile(profile_raw)
    if profile is not None:
        overrides["panel_frame_profile_width_m"] = float(profile[0])
        overrides["panel_frame_profile_height_m"] = float(profile[1])

    params = parameters.load_parameters(config, overrides)

    mesh = icosahedron.build_icosahedron(params.radius_m)
    dome = tessellation.tessellate(mesh, params)

    builder = PanelBuilder(params)

    requested_width = float(params.panel_frame_profile_width_m)
    inset = float(params.panel_frame_inset_m)

    # Gather inner corner points per node.
    inner_points_by_node: dict[int, list[dict[str, object]]] = {}
    panel_failures: list[dict[str, object]] = []

    for panel in dome.panels:
        plane = builder._panel_plane_data(dome, panel)  # type: ignore[attr-defined]
        if plane is None:
            panel_failures.append({"panel": panel.index, "reason": "no_plane"})
            continue

        base_loop = list(plane.coords2d)
        if len(base_loop) < 3:
            panel_failures.append({"panel": panel.index, "reason": "degenerate"})
            continue

        inner_inset = max(0.0, inset) + max(0.0, requested_width)
        inner_loop = builder._validated_inset(base_loop, inner_inset)  # type: ignore[attr-defined]
        if not inner_loop or len(inner_loop) < 3:
            panel_failures.append({"panel": panel.index, "reason": "no_inner_loop"})
            continue
        if len(inner_loop) != len(base_loop):
            panel_failures.append(
                {
                    "panel": panel.index,
                    "reason": "corner_count_mismatch",
                    "outer_corners": len(base_loop),
                    "inner_corners": len(inner_loop),
                }
            )
            continue

        # Mapping is by corner index: inner_loop[i] corresponds to node_indices[i]
        for i, node_idx in enumerate(plane.node_indices):
            p3 = builder._lift_point(plane, inner_loop[i])  # type: ignore[attr-defined]
            inner_points_by_node.setdefault(int(node_idx), []).append(
                {
                    "panel": int(panel.index),
                    "corner_index": int(i),
                    "p": [float(p3[0]), float(p3[1]), float(p3[2])],
                }
            )

    worst_nodes: list[dict[str, object]] = []
    failures = 0

    for node_idx, items in inner_points_by_node.items():
        if len(items) < 2:
            continue
        pts = [tuple(it["p"]) for it in items]  # type: ignore[misc]
        max_d = 0.0
        pair = None
        for i in range(len(pts)):
            for j in range(i + 1, len(pts)):
                d = _dist(pts[i], pts[j])
                if d > max_d:
                    max_d = d
                    pair = (i, j)
        if max_d > tol_m:
            failures += 1
            i, j = pair if pair is not None else (0, 1)
            worst_nodes.append(
                {
                    "node": int(node_idx),
                    "incident_panels": [int(it["panel"]) for it in items],
                    "spread_m": float(max_d),
                    "pair": {
                        "a": items[i],
                        "b": items[j],
                    },
                }
            )

    worst_nodes.sort(key=lambda x: float(x["spread_m"]), reverse=True)

    report = {
        "config": config,
        "params": {
            "radius_m": float(params.radius_m),
            "frequency": int(params.frequency),
            "use_truncation": bool(params.use_truncation),
            "hemisphere_ratio": float(params.hemisphere_ratio),
            "truncation_ratio": float(params.truncation_ratio),
            "inset_m": float(inset),
            "profile_width_m": float(requested_width),
            "profile_height_m": float(params.panel_frame_profile_height_m),
        },
        "tolerance_m": tol_m,
        "counts": {
            "nodes": len(dome.nodes),
            "panels": len(dome.panels),
            "nodes_with_2plus_incident_panels": sum(1 for v in inner_points_by_node.values() if len(v) >= 2),
            "panel_failures": len(panel_failures),
            "failing_nodes": failures,
        },
        "panel_failures": panel_failures[:50],
        "worst_nodes": worst_nodes[:50],
    }

    out_dir = Path(os.environ.get("DOME_OUT_DIR", str(REPO_ROOT / "exports" / "node_inner_corner_spread")))
    out_dir.mkdir(parents=True, exist_ok=True)
    cfg_name = Path(config).stem
    out_path = out_dir / f"node_inner_corner_spread__{cfg_name}.json"
    out_path.write_text(json.dumps(report, indent=2), encoding="utf-8")

    print(f"failing_nodes={failures} tol_m={tol_m} report={out_path}")
    return 1 if failures else 0


if __name__ == "__main__":
    raise SystemExit(main())
